import type {
  ComponentDefinition,
  ComponentCategory,
  ComponentType,
} from "../types/components";

// ─── Category metadata ──────────────────────────────────────────────────────

export const CATEGORY_COLORS: Record<ComponentCategory, string> = {
  clients: "#00f5ff",
  loadbalancing: "#00ff88",
  compute: "#ffb800",
  storage: "#9d4edd",
  messaging: "#ff3860",
  observability: "#00f5ff",
  network: "#ffb800",
  ai: "#c77dff",
};

export const CATEGORY_LABELS: Record<ComponentCategory, string> = {
  clients: "Clients & Ingress",
  loadbalancing: "Load Balancing & Routing",
  compute: "Compute",
  storage: "Data Storage",
  messaging: "Messaging & Async",
  observability: "Observability",
  network: "Network & Security",
  ai: "AI & ML Infrastructure",
};

// ─── Component Definitions ──────────────────────────────────────────────────

export const COMPONENT_DEFINITIONS: ComponentDefinition[] = [
  // ── Clients ────────────────────────────────────────────────────────────
  {
    type: "web-client",
    category: "clients",
    name: "Web Client",
    description: "Browser-based frontend application",
    icon: "Monitor",
    maxThroughput: 100000,
    baseLatency: 0,
    failureRateAtCapacity: 0,
    isHorizontallyScalable: true,
    availabilitySLA: 0.999,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 0,
    defaultConfig: {},
    education: {
      whatIsIt:
        "A browser-based application that users interact with directly. Renders HTML/CSS/JS, makes API calls to backend services.",
      whenToUse: [
        "Every web application",
        "When users need browser access",
        "SPAs, SSR, or hybrid rendering",
      ],
      tradeoffs: {
        pros: ["Universal access", "No installation needed", "Easy updates"],
        cons: [
          "Limited device access",
          "Network dependent",
          "Browser compatibility",
        ],
      },
      realWorldExamples: [
        "Gmail (SPA)",
        "Twitter Web App",
        "Netflix Web Player",
      ],
    },
    color: "#00f5ff",
  },
  {
    type: "mobile-client",
    category: "clients",
    name: "Mobile Client",
    description: "Native or cross-platform mobile app",
    icon: "Smartphone",
    maxThroughput: 50000,
    baseLatency: 5,
    failureRateAtCapacity: 0,
    isHorizontallyScalable: true,
    availabilitySLA: 0.999,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 0,
    defaultConfig: {},
    education: {
      whatIsIt:
        "A mobile application running on iOS or Android that communicates with backend services via APIs.",
      whenToUse: [
        "When you need push notifications",
        "Offline-first experiences",
        "Device sensor access (camera, GPS)",
      ],
      tradeoffs: {
        pros: ["Rich device access", "Offline support", "Push notifications"],
        cons: [
          "App store approval",
          "Version fragmentation",
          "Higher development cost",
        ],
      },
      realWorldExamples: [
        "Uber (native)",
        "Instagram (React Native)",
        "Spotify (native)",
      ],
    },
    color: "#00f5ff",
  },
  {
    type: "api-consumer",
    category: "clients",
    name: "External API Consumer",
    description: "Third-party service consuming your API",
    icon: "Webhook",
    maxThroughput: 100000,
    baseLatency: 0,
    failureRateAtCapacity: 0,
    isHorizontallyScalable: true,
    availabilitySLA: 0.999,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 0,
    defaultConfig: {},
    education: {
      whatIsIt:
        "An external service or partner application that consumes your public API endpoints.",
      whenToUse: ["B2B integrations", "Public APIs", "Webhook receivers"],
      tradeoffs: {
        pros: ["Ecosystem growth", "Revenue via API"],
        cons: ["API versioning burden", "Rate limiting complexity"],
      },
      realWorldExamples: [
        "Stripe API consumers",
        "Twilio integrations",
        "GitHub Apps",
      ],
    },
    color: "#00f5ff",
  },

  // ── Load Balancing & Routing ───────────────────────────────────────────
  {
    type: "load-balancer",
    category: "loadbalancing",
    name: "Load Balancer",
    description: "Distributes traffic across server instances",
    icon: "GitFork",
    maxThroughput: 100000,
    baseLatency: 2,
    failureRateAtCapacity: 0.001,
    isHorizontallyScalable: true,
    availabilitySLA: 0.9999,
    consistencyModel: "strong",
    capAlignment: "CA",
    costPerInstancePerMonth: 25,
    defaultConfig: { algorithm: "round-robin" },
    education: {
      whatIsIt:
        "A load balancer distributes incoming network traffic across multiple backend servers to ensure no single server bears too much load.",
      whenToUse: [
        "Multiple server instances exist",
        "Need high availability",
        "Horizontal scaling of compute tier",
      ],
      tradeoffs: {
        pros: [
          "Improved availability",
          "Horizontal scaling",
          "Health checking",
        ],
        cons: [
          "Additional latency (~2ms)",
          "Single point of failure if not redundant",
          "Session affinity complexity",
        ],
      },
      realWorldExamples: [
        "AWS ALB/NLB",
        "Nginx",
        "HAProxy",
        "Google Cloud Load Balancer",
      ],
    },
    color: "#00ff88",
  },
  {
    type: "api-gateway",
    category: "loadbalancing",
    name: "API Gateway",
    description: "Single entry point for API routing and auth",
    icon: "Shield",
    maxThroughput: 50000,
    baseLatency: 5,
    failureRateAtCapacity: 0.002,
    isHorizontallyScalable: true,
    availabilitySLA: 0.9999,
    consistencyModel: "strong",
    capAlignment: "CA",
    costPerInstancePerMonth: 50,
    defaultConfig: {},
    education: {
      whatIsIt:
        "An API gateway sits in front of your microservices, handling cross-cutting concerns like authentication, rate limiting, request routing, and protocol translation.",
      whenToUse: [
        "Microservices architecture",
        "Need centralized auth/rate-limiting",
        "API versioning",
      ],
      tradeoffs: {
        pros: [
          "Centralized security",
          "Rate limiting",
          "Request transformation",
        ],
        cons: [
          "Additional latency",
          "Can become bottleneck",
          "Added complexity",
        ],
      },
      realWorldExamples: [
        "Kong",
        "AWS API Gateway",
        "Apigee",
        "Zuul (Netflix)",
      ],
    },
    color: "#00ff88",
  },
  {
    type: "cdn",
    category: "loadbalancing",
    name: "CDN",
    description: "Content delivery network for static assets",
    icon: "Globe",
    maxThroughput: 1000000,
    baseLatency: 1,
    failureRateAtCapacity: 0.0001,
    isHorizontallyScalable: true,
    availabilitySLA: 0.99999,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 100,
    defaultConfig: {},
    education: {
      whatIsIt:
        "A globally distributed network of edge servers that cache and serve static content (images, CSS, JS) from locations geographically close to users.",
      whenToUse: [
        "Global user base",
        "Heavy static assets",
        "Video/media streaming",
        "Reducing origin server load",
      ],
      tradeoffs: {
        pros: [
          "Dramatic latency reduction",
          "Origin offloading",
          "DDoS protection",
        ],
        cons: [
          "Cache invalidation complexity",
          "Cost at scale",
          "Eventual consistency of cached content",
        ],
      },
      realWorldExamples: ["CloudFlare", "AWS CloudFront", "Akamai", "Fastly"],
    },
    color: "#00ff88",
  },
  {
    type: "reverse-proxy",
    category: "loadbalancing",
    name: "Reverse Proxy",
    description: "Intermediate proxy for security and caching",
    icon: "ArrowLeftRight",
    maxThroughput: 80000,
    baseLatency: 1,
    failureRateAtCapacity: 0.001,
    isHorizontallyScalable: true,
    availabilitySLA: 0.9999,
    consistencyModel: "strong",
    capAlignment: "CA",
    costPerInstancePerMonth: 20,
    defaultConfig: {},
    education: {
      whatIsIt:
        "A server that sits between clients and backend servers, forwarding client requests and returning server responses, while adding security, caching, and SSL termination.",
      whenToUse: [
        "SSL termination",
        "Response caching",
        "Hiding backend topology",
      ],
      tradeoffs: {
        pros: ["Security layer", "SSL offloading", "Response caching"],
        cons: ["Additional hop", "Configuration complexity"],
      },
      realWorldExamples: ["Nginx", "Envoy", "Traefik", "Caddy"],
    },
    color: "#00ff88",
  },
  {
    type: "dns-server",
    category: "loadbalancing",
    name: "DNS Server",
    description: "Domain name resolution and geographic routing",
    icon: "MapPin",
    maxThroughput: 500000,
    baseLatency: 10,
    failureRateAtCapacity: 0.0001,
    isHorizontallyScalable: true,
    availabilitySLA: 0.99999,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 5,
    defaultConfig: {},
    education: {
      whatIsIt:
        "DNS (Domain Name System) translates human-readable domain names to IP addresses. Advanced DNS can perform geographic-based routing and load balancing.",
      whenToUse: [
        "Multi-region deployments",
        "Geographic routing",
        "Failover between data centers",
      ],
      tradeoffs: {
        pros: ["Global routing", "Failover support", "Very low cost"],
        cons: [
          "TTL-based caching delays",
          "Limited health checking",
          "Propagation time",
        ],
      },
      realWorldExamples: ["AWS Route 53", "Cloudflare DNS", "Google Cloud DNS"],
    },
    color: "#00ff88",
  },

  // ── Compute ────────────────────────────────────────────────────────────
  {
    type: "web-server",
    category: "compute",
    name: "Web Server",
    description: "Application server handling HTTP requests",
    icon: "Server",
    maxThroughput: 5000,
    baseLatency: 15,
    failureRateAtCapacity: 0.01,
    isHorizontallyScalable: true,
    availabilitySLA: 0.999,
    consistencyModel: "strong",
    capAlignment: "CA",
    costPerInstancePerMonth: 80,
    defaultConfig: { runtime: "node" },
    education: {
      whatIsIt:
        "An application server that processes HTTP requests, executes business logic, connects to databases, and returns responses. The workhorse of most web architectures.",
      whenToUse: [
        "Core API handling",
        "Business logic execution",
        "Request/response processing",
      ],
      tradeoffs: {
        pros: ["Flexible", "Stateful processing", "Full language ecosystem"],
        cons: [
          "Requires scaling strategy",
          "Memory/CPU bound",
          "Deployment complexity",
        ],
      },
      realWorldExamples: [
        "Express.js (Node)",
        "Django (Python)",
        "Spring Boot (Java)",
        "Rails (Ruby)",
      ],
    },
    color: "#ffb800",
  },
  {
    type: "microservice",
    category: "compute",
    name: "Microservice",
    description: "Independently deployable service unit",
    icon: "Box",
    maxThroughput: 8000,
    baseLatency: 10,
    failureRateAtCapacity: 0.005,
    isHorizontallyScalable: true,
    availabilitySLA: 0.999,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 60,
    defaultConfig: {},
    education: {
      whatIsIt:
        "A small, independently deployable service that owns a specific business capability. Communicates with other services via APIs or messaging.",
      whenToUse: [
        "Large teams needing independent deployment",
        "Different scaling needs per service",
        "Polyglot technology requirements",
      ],
      tradeoffs: {
        pros: [
          "Independent scaling",
          "Technology flexibility",
          "Fault isolation",
        ],
        cons: [
          "Network latency between services",
          "Data consistency challenges",
          "Operational complexity",
        ],
      },
      realWorldExamples: ["Netflix (700+ microservices)", "Uber", "Amazon"],
    },
    color: "#ffb800",
  },
  {
    type: "serverless-function",
    category: "compute",
    name: "Serverless Function",
    description: "Event-driven, auto-scaling compute unit",
    icon: "Zap",
    maxThroughput: 10000,
    baseLatency: 50,
    failureRateAtCapacity: 0.002,
    isHorizontallyScalable: true,
    availabilitySLA: 0.9999,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 5,
    defaultConfig: {},
    education: {
      whatIsIt:
        "A function that runs in response to events, automatically scaling from zero to thousands of concurrent instances. You pay only for execution time.",
      whenToUse: [
        "Unpredictable traffic patterns",
        "Event-driven processing",
        "Cost optimization for sporadic workloads",
      ],
      tradeoffs: {
        pros: [
          "Zero idle cost",
          "Auto-scaling",
          "No infrastructure management",
        ],
        cons: [
          "Cold start latency (50-500ms)",
          "Execution time limits",
          "Stateless only",
        ],
      },
      realWorldExamples: [
        "AWS Lambda",
        "Google Cloud Functions",
        "Cloudflare Workers",
      ],
    },
    color: "#ffb800",
  },
  {
    type: "container-pod",
    category: "compute",
    name: "Container / Pod",
    description: "Containerized workload in Kubernetes",
    icon: "Container",
    maxThroughput: 6000,
    baseLatency: 12,
    failureRateAtCapacity: 0.005,
    isHorizontallyScalable: true,
    availabilitySLA: 0.999,
    consistencyModel: "strong",
    capAlignment: "CA",
    costPerInstancePerMonth: 50,
    defaultConfig: {},
    education: {
      whatIsIt:
        "A lightweight, portable container running your application with its dependencies. Orchestrated by Kubernetes for auto-scaling, rolling updates, and self-healing.",
      whenToUse: [
        "Microservices deployment",
        "Need portability across clouds",
        "Auto-scaling with health checks",
      ],
      tradeoffs: {
        pros: ["Portability", "Resource efficiency", "Auto-healing"],
        cons: [
          "Kubernetes complexity",
          "Networking overhead",
          "Persistent storage challenges",
        ],
      },
      realWorldExamples: [
        "Docker containers on Kubernetes",
        "AWS ECS/EKS",
        "Google GKE",
      ],
    },
    color: "#ffb800",
  },

  // ── Data Storage ───────────────────────────────────────────────────────
  {
    type: "postgresql",
    category: "storage",
    name: "PostgreSQL",
    description: "Relational database with ACID compliance",
    icon: "Database",
    maxThroughput: 3000,
    baseLatency: 5,
    failureRateAtCapacity: 0.01,
    isHorizontallyScalable: false,
    availabilitySLA: 0.999,
    consistencyModel: "strong",
    capAlignment: "CP",
    costPerInstancePerMonth: 200,
    defaultConfig: { engine: "PostgreSQL 16" },
    education: {
      whatIsIt:
        "A powerful open-source relational database with full ACID compliance, complex queries, joins, and strict data integrity. The gold standard for structured data.",
      whenToUse: [
        "Complex queries and joins",
        "Financial transactions",
        "Data integrity is paramount",
        "Relational data with foreign keys",
      ],
      tradeoffs: {
        pros: [
          "ACID transactions",
          "Complex queries",
          "Data integrity",
          "Extensions (PostGIS, JSONB)",
        ],
        cons: [
          "Vertical scaling primarily",
          "Sharding is complex",
          "Read replicas add eventual consistency",
        ],
      },
      realWorldExamples: ["Instagram", "Reddit", "Twitch", "Apple"],
    },
    color: "#9d4edd",
  },
  {
    type: "mysql",
    category: "storage",
    name: "MySQL",
    description: "Popular relational database",
    icon: "Database",
    maxThroughput: 4000,
    baseLatency: 4,
    failureRateAtCapacity: 0.01,
    isHorizontallyScalable: false,
    availabilitySLA: 0.999,
    consistencyModel: "strong",
    capAlignment: "CP",
    costPerInstancePerMonth: 150,
    defaultConfig: { engine: "MySQL 8.0" },
    education: {
      whatIsIt:
        "An open-source relational database known for simplicity, reliability, and performance. Widely used in web applications with read-heavy workloads.",
      whenToUse: [
        "Web application backends",
        "Read-heavy workloads",
        "When simplicity matters",
      ],
      tradeoffs: {
        pros: [
          "Widely supported",
          "Good read performance",
          "Mature replication",
        ],
        cons: [
          "Less advanced than PostgreSQL",
          "Sharding requires middleware",
          "Limited JSON support",
        ],
      },
      realWorldExamples: ["Facebook", "Twitter", "YouTube", "Shopify"],
    },
    color: "#9d4edd",
  },
  {
    type: "mongodb",
    category: "storage",
    name: "MongoDB",
    description: "Document-oriented NoSQL database",
    icon: "FileJson",
    maxThroughput: 10000,
    baseLatency: 3,
    failureRateAtCapacity: 0.005,
    isHorizontallyScalable: true,
    availabilitySLA: 0.999,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 180,
    defaultConfig: {},
    education: {
      whatIsIt:
        "A document-oriented NoSQL database that stores data as flexible JSON-like documents. Designed for horizontal scaling and schema flexibility.",
      whenToUse: [
        "Rapidly evolving schemas",
        "Document-centric data",
        "High write throughput",
        "Geographically distributed data",
      ],
      tradeoffs: {
        pros: ["Flexible schema", "Horizontal scaling", "Developer-friendly"],
        cons: [
          "No joins (denormalization needed)",
          "Eventual consistency by default",
          "Memory-heavy",
        ],
      },
      realWorldExamples: ["eBay (catalog)", "Forbes", "Adobe (content)"],
    },
    color: "#9d4edd",
  },
  {
    type: "cassandra",
    category: "storage",
    name: "Cassandra",
    description: "Wide-column distributed NoSQL database",
    icon: "Columns3",
    maxThroughput: 20000,
    baseLatency: 4,
    failureRateAtCapacity: 0.002,
    isHorizontallyScalable: true,
    availabilitySLA: 0.9999,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 250,
    defaultConfig: {},
    education: {
      whatIsIt:
        "A distributed wide-column store designed for handling large amounts of data across many commodity servers with no single point of failure.",
      whenToUse: [
        "Massive write throughput",
        "Multi-datacenter replication",
        "Time-series data",
        "Always-on availability required",
      ],
      tradeoffs: {
        pros: ["Linear scalability", "Multi-DC replication", "No SPOF"],
        cons: [
          "Limited query flexibility",
          "Eventual consistency",
          "Data modeling is complex",
        ],
      },
      realWorldExamples: [
        "Netflix",
        "Apple (iMessage)",
        "Instagram (audit logs)",
      ],
    },
    color: "#9d4edd",
  },
  {
    type: "dynamodb",
    category: "storage",
    name: "DynamoDB",
    description: "Managed key-value and document database",
    icon: "TableProperties",
    maxThroughput: 15000,
    baseLatency: 5,
    failureRateAtCapacity: 0.001,
    isHorizontallyScalable: true,
    availabilitySLA: 0.9999,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 200,
    defaultConfig: {},
    education: {
      whatIsIt:
        "A fully managed, serverless, key-value NoSQL database by AWS designed for single-digit millisecond performance at any scale.",
      whenToUse: [
        "Serverless architectures",
        "Predictable performance at scale",
        "Simple key-value access patterns",
      ],
      tradeoffs: {
        pros: ["Fully managed", "Consistent performance", "Auto-scaling"],
        cons: ["AWS lock-in", "Limited query patterns", "Expensive at scale"],
      },
      realWorldExamples: ["Amazon.com", "Lyft", "Duolingo", "Samsung"],
    },
    color: "#9d4edd",
  },
  {
    type: "redis-cache",
    category: "storage",
    name: "Redis Cache",
    description: "In-memory key-value store for caching",
    icon: "Gauge",
    maxThroughput: 100000,
    baseLatency: 1,
    failureRateAtCapacity: 0.001,
    isHorizontallyScalable: true,
    availabilitySLA: 0.999,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 50,
    defaultConfig: { ttl: 3600 },
    education: {
      whatIsIt:
        "An in-memory data store used primarily as a cache, session store, or message broker. Sub-millisecond response times for read-heavy workloads.",
      whenToUse: [
        "Caching database queries",
        "Session storage",
        "Rate limiting",
        "Real-time leaderboards",
      ],
      tradeoffs: {
        pros: [
          "Sub-millisecond latency",
          "Rich data structures",
          "Pub/sub support",
        ],
        cons: [
          "Memory cost",
          "Data loss on restart (without persistence)",
          "Cache invalidation complexity",
        ],
      },
      realWorldExamples: [
        "Twitter (timeline cache)",
        "GitHub (caching)",
        "Stack Overflow",
      ],
    },
    color: "#9d4edd",
  },
  {
    type: "memcached",
    category: "storage",
    name: "Memcached",
    description: "Simple distributed memory caching",
    icon: "MemoryStick",
    maxThroughput: 120000,
    baseLatency: 1,
    failureRateAtCapacity: 0.001,
    isHorizontallyScalable: true,
    availabilitySLA: 0.999,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 40,
    defaultConfig: { ttl: 3600 },
    education: {
      whatIsIt:
        "A simple, high-performance distributed memory caching system. Stores key-value pairs in RAM for fast access. Simpler than Redis but extremely fast.",
      whenToUse: [
        "Simple key-value caching",
        "When you need maximum throughput",
        "Large cache pools",
      ],
      tradeoffs: {
        pros: ["Very fast", "Simple", "Multi-threaded"],
        cons: ["No persistence", "No complex data types", "No pub/sub"],
      },
      realWorldExamples: ["Facebook", "Wikipedia", "YouTube"],
    },
    color: "#9d4edd",
  },
  {
    type: "object-storage",
    category: "storage",
    name: "Object Storage (S3)",
    description: "Scalable storage for files and blobs",
    icon: "HardDrive",
    maxThroughput: 50000,
    baseLatency: 20,
    failureRateAtCapacity: 0.0001,
    isHorizontallyScalable: true,
    availabilitySLA: 0.99999,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 30,
    defaultConfig: {},
    education: {
      whatIsIt:
        "A massively scalable object store for unstructured data — images, videos, backups, logs. Designed for 99.999999999% (11 nines) durability.",
      whenToUse: [
        "File/image/video storage",
        "Backups",
        "Data lake storage",
        "Static website hosting",
      ],
      tradeoffs: {
        pros: ["Virtually unlimited scale", "Very cheap", "Extremely durable"],
        cons: [
          "Higher latency than databases",
          "Not for transactional data",
          "Eventual consistency",
        ],
      },
      realWorldExamples: [
        "AWS S3",
        "Google Cloud Storage",
        "Azure Blob Storage",
      ],
    },
    color: "#9d4edd",
  },
  {
    type: "data-warehouse",
    category: "storage",
    name: "Data Warehouse",
    description: "Analytical database for OLAP queries",
    icon: "Warehouse",
    maxThroughput: 500,
    baseLatency: 200,
    failureRateAtCapacity: 0.005,
    isHorizontallyScalable: true,
    availabilitySLA: 0.999,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 500,
    defaultConfig: {},
    education: {
      whatIsIt:
        "A database optimized for analytical queries over large datasets. Uses columnar storage for fast aggregation, designed for OLAP (Online Analytical Processing).",
      whenToUse: [
        "Business intelligence",
        "Large-scale analytics",
        "Historical data analysis",
        "Complex aggregation queries",
      ],
      tradeoffs: {
        pros: [
          "Fast analytical queries",
          "Handles petabytes",
          "Columnar storage",
        ],
        cons: [
          "Not for transactional workloads",
          "High latency for point queries",
          "Expensive",
        ],
      },
      realWorldExamples: ["Snowflake", "Amazon Redshift", "Google BigQuery"],
    },
    color: "#9d4edd",
  },

  // ── Messaging & Async ──────────────────────────────────────────────────
  {
    type: "message-queue",
    category: "messaging",
    name: "Message Queue",
    description: "Asynchronous message broker (RabbitMQ/SQS)",
    icon: "Mail",
    maxThroughput: 20000,
    baseLatency: 15,
    failureRateAtCapacity: 0.002,
    isHorizontallyScalable: true,
    availabilitySLA: 0.9999,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 40,
    defaultConfig: {},
    education: {
      whatIsIt:
        "A message broker that decouples producers from consumers. Messages are stored in a queue and processed asynchronously, ensuring reliable delivery.",
      whenToUse: [
        "Decouple services",
        "Buffer traffic spikes",
        "Async processing (email, notifications)",
        "Task queues",
      ],
      tradeoffs: {
        pros: ["Decoupling", "Spike buffering", "Guaranteed delivery"],
        cons: [
          "Added latency",
          "Message ordering challenges",
          "Monitoring complexity",
        ],
      },
      realWorldExamples: ["RabbitMQ", "Amazon SQS", "Azure Service Bus"],
    },
    color: "#ff3860",
  },
  {
    type: "event-stream",
    category: "messaging",
    name: "Event Stream (Kafka)",
    description: "Distributed event streaming platform",
    icon: "Radio",
    maxThroughput: 100000,
    baseLatency: 10,
    failureRateAtCapacity: 0.001,
    isHorizontallyScalable: true,
    availabilitySLA: 0.9999,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 150,
    defaultConfig: {},
    education: {
      whatIsIt:
        "A distributed streaming platform for building real-time data pipelines. Unlike queues, events are retained and can be replayed by multiple consumers.",
      whenToUse: [
        "Event-driven architectures",
        "Real-time data pipelines",
        "Event sourcing",
        "Log aggregation at scale",
      ],
      tradeoffs: {
        pros: ["Massive throughput", "Event replay", "Multi-consumer"],
        cons: [
          "Operational complexity",
          "Ordering only within partitions",
          "Steep learning curve",
        ],
      },
      realWorldExamples: ["LinkedIn", "Uber", "Netflix", "Airbnb"],
    },
    color: "#ff3860",
  },
  {
    type: "pub-sub",
    category: "messaging",
    name: "Pub/Sub System",
    description: "Publish-subscribe messaging pattern",
    icon: "Bell",
    maxThroughput: 50000,
    baseLatency: 8,
    failureRateAtCapacity: 0.002,
    isHorizontallyScalable: true,
    availabilitySLA: 0.9999,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 30,
    defaultConfig: {},
    education: {
      whatIsIt:
        "A messaging pattern where publishers send messages to topics and subscribers receive messages from topics they are interested in. Enables fan-out messaging.",
      whenToUse: [
        "Event notifications",
        "Fan-out to multiple consumers",
        "Real-time updates",
        "Webhook delivery",
      ],
      tradeoffs: {
        pros: [
          "Decoupled publishers/subscribers",
          "Fan-out support",
          "Scalable",
        ],
        cons: [
          "No guaranteed ordering",
          "At-least-once delivery",
          "Topic management overhead",
        ],
      },
      realWorldExamples: ["Google Cloud Pub/Sub", "AWS SNS", "Redis Pub/Sub"],
    },
    color: "#ff3860",
  },

  // ── Observability ──────────────────────────────────────────────────────
  {
    type: "metrics-collector",
    category: "observability",
    name: "Metrics Collector",
    description: "System metrics aggregation service",
    icon: "BarChart3",
    maxThroughput: 50000,
    baseLatency: 0,
    failureRateAtCapacity: 0.001,
    isHorizontallyScalable: true,
    availabilitySLA: 0.999,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 30,
    defaultConfig: {},
    education: {
      whatIsIt:
        "A service that collects, aggregates, and stores metrics from all components in your system. Enables dashboards, alerting, and capacity planning.",
      whenToUse: [
        "Production monitoring",
        "SLA tracking",
        "Capacity planning",
        "Alert management",
      ],
      tradeoffs: {
        pros: [
          "Visibility into system health",
          "Alerting support",
          "Historical analysis",
        ],
        cons: [
          "Storage costs grow with metrics",
          "Cardinality explosion risk",
          "Can add overhead",
        ],
      },
      realWorldExamples: ["Prometheus + Grafana", "Datadog", "New Relic"],
    },
    color: "#00f5ff",
  },
  {
    type: "log-aggregator",
    category: "observability",
    name: "Log Aggregator",
    description: "Centralized log collection and search",
    icon: "ScrollText",
    maxThroughput: 30000,
    baseLatency: 0,
    failureRateAtCapacity: 0.002,
    isHorizontallyScalable: true,
    availabilitySLA: 0.999,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 80,
    defaultConfig: {},
    education: {
      whatIsIt:
        "A centralized system for collecting, indexing, and searching logs from all services. Essential for debugging distributed systems.",
      whenToUse: [
        "Debugging production issues",
        "Audit trails",
        "Compliance requirements",
        "Distributed tracing context",
      ],
      tradeoffs: {
        pros: ["Centralized debugging", "Full-text search", "Correlate events"],
        cons: [
          "High storage costs",
          "Ingestion bottleneck risk",
          "Sensitive data exposure",
        ],
      },
      realWorldExamples: [
        "ELK Stack (Elasticsearch)",
        "Splunk",
        "Loki + Grafana",
      ],
    },
    color: "#00f5ff",
  },
  {
    type: "distributed-tracer",
    category: "observability",
    name: "Distributed Tracer",
    description: "Request tracing across services",
    icon: "Radar",
    maxThroughput: 20000,
    baseLatency: 0,
    failureRateAtCapacity: 0.001,
    isHorizontallyScalable: true,
    availabilitySLA: 0.999,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 60,
    defaultConfig: {},
    education: {
      whatIsIt:
        "A system that tracks requests as they flow through multiple services, creating a trace that shows the entire call chain, timing, and failures.",
      whenToUse: [
        "Microservices debugging",
        "Latency optimization",
        "Understanding request flow",
        "Identifying bottlenecks",
      ],
      tradeoffs: {
        pros: [
          "End-to-end visibility",
          "Latency breakdown",
          "Error correlation",
        ],
        cons: [
          "Instrumentation overhead",
          "Sampling needed at scale",
          "Storage costs",
        ],
      },
      realWorldExamples: ["Jaeger", "Zipkin", "AWS X-Ray", "Honeycomb"],
    },
    color: "#00f5ff",
  },

  // ── Network & Security ─────────────────────────────────────────────────
  {
    type: "firewall-waf",
    category: "network",
    name: "Firewall / WAF",
    description: "Web application firewall and traffic filtering",
    icon: "ShieldAlert",
    maxThroughput: 200000,
    baseLatency: 1,
    failureRateAtCapacity: 0.0001,
    isHorizontallyScalable: true,
    availabilitySLA: 0.9999,
    consistencyModel: "strong",
    capAlignment: "CA",
    costPerInstancePerMonth: 35,
    defaultConfig: {},
    education: {
      whatIsIt:
        "A Web Application Firewall filters and monitors HTTP traffic to protect against common web exploits like SQL injection, XSS, and DDoS attacks.",
      whenToUse: [
        "Public-facing APIs",
        "E-commerce platforms",
        "Compliance requirements (PCI-DSS)",
        "DDoS protection",
      ],
      tradeoffs: {
        pros: ["Security layer", "DDoS mitigation", "Compliance"],
        cons: [
          "False positives",
          "Slight latency increase",
          "Rule maintenance",
        ],
      },
      realWorldExamples: ["AWS WAF", "Cloudflare WAF", "Akamai Kona"],
    },
    color: "#ffb800",
  },
  {
    type: "vpn-private-network",
    category: "network",
    name: "VPN / Private Network",
    description: "Isolated private network layer",
    icon: "Lock",
    maxThroughput: 100000,
    baseLatency: 2,
    failureRateAtCapacity: 0.0001,
    isHorizontallyScalable: true,
    availabilitySLA: 0.9999,
    consistencyModel: "strong",
    capAlignment: "CA",
    costPerInstancePerMonth: 20,
    defaultConfig: {},
    education: {
      whatIsIt:
        "A Virtual Private Cloud (VPC) or VPN creates an isolated network for your services, ensuring internal communication is encrypted and protected from the public internet.",
      whenToUse: [
        "Internal service communication",
        "Data sovereignty requirements",
        "Multi-cloud networking",
        "Hybrid cloud connectivity",
      ],
      tradeoffs: {
        pros: [
          "Network isolation",
          "Encrypted communication",
          "Access control",
        ],
        cons: [
          "Added network complexity",
          "Cross-VPC latency",
          "VPN throughput limits",
        ],
      },
      realWorldExamples: ["AWS VPC", "Google Cloud VPN", "Azure VNet"],
    },
    color: "#ffb800",
  },

  // ── AI & ML Infrastructure ──────────────────────────────────────────────
  {
    type: "llm-inference",
    category: "ai",
    name: "LLM Inference",
    description: "Serves a Large Language Model over an API",
    icon: "Brain",
    maxThroughput: 500,
    baseLatency: 800,
    failureRateAtCapacity: 0.01,
    isHorizontallyScalable: true,
    availabilitySLA: 0.995,
    consistencyModel: "strong",
    capAlignment: "CP",
    costPerInstancePerMonth: 2000,
    defaultConfig: { model: "gpt-4" },
    education: {
      whatIsIt:
        "Serves a Large Language Model (GPT-4, Claude, Llama, etc.) over an API. Generates text, answers questions, and reasons about input.",
      whenToUse: [
        "When your system needs to understand, generate, or reason about text",
        "Chatbots, content generation, code assistance",
        "Complex reasoning and decision-making tasks",
      ],
      tradeoffs: {
        pros: ["Powerful reasoning", "Flexible output", "Few-shot learning"],
        cons: [
          "High latency (300ms–2s)",
          "Expensive GPU costs",
          "Variable response length",
        ],
      },
      realWorldExamples: ["OpenAI API", "AWS Bedrock", "Groq", "Together AI"],
    },
    color: "#ffd60a",
  },
  {
    type: "vector-database",
    category: "ai",
    name: "Vector Database",
    description: "Stores and queries high-dimensional vector embeddings",
    icon: "Compass",
    maxThroughput: 5000,
    baseLatency: 20,
    failureRateAtCapacity: 0.005,
    isHorizontallyScalable: true,
    availabilitySLA: 0.999,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 300,
    defaultConfig: {},
    education: {
      whatIsIt:
        "Stores and queries high-dimensional vector embeddings for semantic search. Finds 'similar' content via mathematical distance in embedding space.",
      whenToUse: [
        "Semantic search — finding similar items by meaning, not keywords",
        "RAG pipeline retrieval step",
        "Recommendation systems, image similarity",
      ],
      tradeoffs: {
        pros: [
          "Semantic understanding",
          "Fast nearest-neighbor search",
          "Scalable",
        ],
        cons: [
          "Approximate results (not 100% accurate)",
          "Memory-intensive",
          "Complex to tune (HNSW, IVF parameters)",
        ],
      },
      realWorldExamples: ["Pinecone", "Weaviate", "Qdrant", "pgvector"],
    },
    color: "#c77dff",
  },
  {
    type: "embedding-service",
    category: "ai",
    name: "Embedding Service",
    description: "Converts text/images to vector embeddings",
    icon: "Fingerprint",
    maxThroughput: 2000,
    baseLatency: 50,
    failureRateAtCapacity: 0.003,
    isHorizontallyScalable: true,
    availabilitySLA: 0.999,
    consistencyModel: "strong",
    capAlignment: "CP",
    costPerInstancePerMonth: 200,
    defaultConfig: {},
    education: {
      whatIsIt:
        "Converts text, images, or other data into dense vector representations (embeddings) that capture semantic meaning.",
      whenToUse: [
        "Preprocessing step before vector database storage",
        "Semantic similarity comparisons",
        "Multi-modal search (text + images)",
      ],
      tradeoffs: {
        pros: [
          "Captures semantic meaning",
          "Language-agnostic",
          "Reusable representations",
        ],
        cons: [
          "GPU required for speed",
          "Model choice affects quality",
          "Embedding drift over time",
        ],
      },
      realWorldExamples: ["OpenAI Embeddings", "Cohere Embed", "Sentence-BERT"],
    },
    color: "#c77dff",
  },
  {
    type: "ai-gateway",
    category: "ai",
    name: "AI Gateway",
    description: "Rate limiting, routing, and cost control for AI APIs",
    icon: "Shield",
    maxThroughput: 10000,
    baseLatency: 5,
    failureRateAtCapacity: 0.001,
    isHorizontallyScalable: true,
    availabilitySLA: 0.9999,
    consistencyModel: "strong",
    capAlignment: "CP",
    costPerInstancePerMonth: 100,
    defaultConfig: {},
    education: {
      whatIsIt:
        "A gateway that manages access to AI/LLM APIs. Provides rate limiting, API key management, cost tracking, fallback routing, and usage analytics.",
      whenToUse: [
        "When you need rate limiting on LLM calls",
        "Multi-model routing (GPT-4, Claude, Llama)",
        "Cost control and budget enforcement",
      ],
      tradeoffs: {
        pros: [
          "Cost control",
          "Rate limiting",
          "Model fallback",
          "Usage analytics",
        ],
        cons: [
          "Additional hop latency",
          "Single point of failure if not replicated",
          "Complexity in routing logic",
        ],
      },
      realWorldExamples: [
        "Portkey",
        "LiteLLM Proxy",
        "Helicone",
        "Kong AI Gateway",
      ],
    },
    color: "#c77dff",
  },
  {
    type: "agent-orchestrator",
    category: "ai",
    name: "Agent Orchestrator",
    description: "Coordinates multiple AI agents for complex tasks",
    icon: "Waypoints",
    maxThroughput: 100,
    baseLatency: 2000,
    failureRateAtCapacity: 0.05,
    isHorizontallyScalable: true,
    availabilitySLA: 0.99,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 500,
    defaultConfig: {},
    education: {
      whatIsIt:
        "Coordinates multiple AI agents to complete complex multi-step tasks autonomously. Each agent can use tools, sub-delegate, and maintain its own reasoning chain.",
      whenToUse: [
        "Multi-step tasks requiring sequential decisions",
        "Tool use and sub-task delegation",
        "Complex workflows with branching logic",
      ],
      tradeoffs: {
        pros: [
          "Handles complex tasks",
          "Tool use capability",
          "Autonomous execution",
        ],
        cons: [
          "Hard to debug",
          "Expensive (many LLM calls)",
          "Can loop or fail unpredictably",
        ],
      },
      realWorldExamples: [
        "AutoGPT",
        "CrewAI",
        "LangGraph",
        "OpenAI Assistants API",
      ],
    },
    color: "#00f5ff",
  },
  {
    type: "rag-pipeline",
    category: "ai",
    name: "RAG Pipeline",
    description: "Retrieval-Augmented Generation for grounded AI responses",
    icon: "Library",
    maxThroughput: 300,
    baseLatency: 500,
    failureRateAtCapacity: 0.02,
    isHorizontallyScalable: true,
    availabilitySLA: 0.995,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 400,
    defaultConfig: {},
    education: {
      whatIsIt:
        "Retrieval-Augmented Generation: fetches relevant documents from a knowledge base, injects them into the LLM context, and generates grounded answers.",
      whenToUse: [
        "When LLM needs to answer about private or recent data",
        "Reducing hallucination in domain-specific Q&A",
        "Enterprise chatbots with internal knowledge",
      ],
      tradeoffs: {
        pros: [
          "Reduces hallucination",
          "Uses private data",
          "No fine-tuning needed",
        ],
        cons: [
          "Adds retrieval latency (+100–500ms)",
          "Requires good chunking strategy",
          "Complex to debug end-to-end",
        ],
      },
      realWorldExamples: [
        "Perplexity AI",
        "Enterprise chatbots",
        "Customer support AI",
      ],
    },
    color: "#00ff88",
  },
  {
    type: "guardrails",
    category: "ai",
    name: "Guardrails",
    description: "Validates LLM input/output for safety and compliance",
    icon: "ShieldCheck",
    maxThroughput: 5000,
    baseLatency: 20,
    failureRateAtCapacity: 0.001,
    isHorizontallyScalable: true,
    availabilitySLA: 0.9999,
    consistencyModel: "strong",
    capAlignment: "CP",
    costPerInstancePerMonth: 80,
    defaultConfig: {},
    education: {
      whatIsIt:
        "Validates LLM input/output for harmful content, PII, format compliance, and prompt injection. A safety layer between users and the LLM.",
      whenToUse: [
        "Always — in every production LLM system",
        "PII detection and redaction",
        "Prompt injection defense",
      ],
      tradeoffs: {
        pros: [
          "Safety compliance",
          "PII protection",
          "Prompt injection defense",
        ],
        cons: [
          "Adds 15–30ms latency",
          "May over-block edge cases",
          "Requires tuning per use case",
        ],
      },
      realWorldExamples: [
        "NeMo Guardrails",
        "Llama Guard",
        "Azure Content Safety",
      ],
    },
    color: "#ff3860",
  },
  {
    type: "prompt-cache",
    category: "ai",
    name: "Prompt Cache",
    description: "Caches similar prompt+response pairs to reduce LLM calls",
    icon: "Zap",
    maxThroughput: 20000,
    baseLatency: 5,
    failureRateAtCapacity: 0.001,
    isHorizontallyScalable: true,
    availabilitySLA: 0.999,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 60,
    defaultConfig: {},
    education: {
      whatIsIt:
        "Caches identical or semantically similar prompt+response pairs to avoid redundant LLM inference calls. Can use exact match or semantic similarity.",
      whenToUse: [
        "Many users asking similar questions (FAQs)",
        "Repeated queries in product lookups",
        "Cost reduction on high-volume LLM endpoints",
      ],
      tradeoffs: {
        pros: [
          "Major cost savings",
          "Sub-10ms cache hits",
          "Reduces GPU pressure",
        ],
        cons: [
          "Semantic cache may return wrong answers",
          "Requires Redis or vector store backend",
          "Cache invalidation complexity",
        ],
      },
      realWorldExamples: [
        "OpenAI prompt caching",
        "GPTCache",
        "LangChain cache",
      ],
    },
    color: "#ffd60a",
  },
  {
    type: "model-registry",
    category: "ai",
    name: "Model Registry",
    description: "Version control and deployment management for ML models",
    icon: "FolderGit2",
    maxThroughput: 1000,
    baseLatency: 10,
    failureRateAtCapacity: 0.001,
    isHorizontallyScalable: false,
    availabilitySLA: 0.999,
    consistencyModel: "strong",
    capAlignment: "CP",
    costPerInstancePerMonth: 100,
    defaultConfig: {},
    education: {
      whatIsIt:
        "A central repository for ML model artifacts — tracks versions, metadata, lineage, and deployment status. Enables reproducible model management.",
      whenToUse: [
        "Multiple models in production simultaneously",
        "A/B testing different model versions",
        "Compliance and audit requirements",
      ],
      tradeoffs: {
        pros: ["Version control", "Reproducibility", "Deployment tracking"],
        cons: [
          "Storage costs for large models",
          "Setup overhead",
          "Requires CI/CD integration",
        ],
      },
      realWorldExamples: [
        "MLflow",
        "Weights & Biases",
        "AWS SageMaker Model Registry",
      ],
    },
    color: "#c77dff",
  },
  {
    type: "feature-store",
    category: "ai",
    name: "Feature Store",
    description:
      "Centralized storage for ML features with online/offline serving",
    icon: "LayoutGrid",
    maxThroughput: 10000,
    baseLatency: 5,
    failureRateAtCapacity: 0.002,
    isHorizontallyScalable: true,
    availabilitySLA: 0.999,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 200,
    defaultConfig: {},
    education: {
      whatIsIt:
        "A centralized repository for computing, storing, and serving ML features. Provides consistent feature values for both training and inference.",
      whenToUse: [
        "Teams sharing features across multiple models",
        "Online serving requiring low-latency feature lookups",
        "Preventing training-serving skew",
      ],
      tradeoffs: {
        pros: ["Feature reuse", "Consistency", "Low-latency serving"],
        cons: [
          "Infrastructure overhead",
          "Complex to maintain",
          "Storage costs at scale",
        ],
      },
      realWorldExamples: ["Feast", "Tecton", "AWS SageMaker Feature Store"],
    },
    color: "#c77dff",
  },
  {
    type: "tool-executor",
    category: "ai",
    name: "Tool Executor",
    description: "Executes function calls / tool use invoked by AI agents",
    icon: "Wrench",
    maxThroughput: 2000,
    baseLatency: 100,
    failureRateAtCapacity: 0.01,
    isHorizontallyScalable: true,
    availabilitySLA: 0.999,
    consistencyModel: "strong",
    capAlignment: "CP",
    costPerInstancePerMonth: 80,
    defaultConfig: {},
    education: {
      whatIsIt:
        "Executes function calls triggered by AI agents — API calls, database queries, calculations, web searches, or any external action the LLM decides to take.",
      whenToUse: [
        "AI agents that need to take actions (not just generate text)",
        "When LLMs need to query databases or APIs",
        "Multi-step agentic workflows",
      ],
      tradeoffs: {
        pros: [
          "Extends LLM capabilities",
          "Sandboxed execution",
          "Auditable actions",
        ],
        cons: [
          "Security risk (code execution)",
          "Latency from external calls",
          "Error handling complexity",
        ],
      },
      realWorldExamples: [
        "OpenAI function calling",
        "LangChain Tools",
        "Semantic Kernel",
      ],
    },
    color: "#00f5ff",
  },
  {
    type: "memory-store",
    category: "ai",
    name: "Memory Store",
    description: "Persistent memory for AI agents across sessions",
    icon: "HardDrive",
    maxThroughput: 5000,
    baseLatency: 10,
    failureRateAtCapacity: 0.002,
    isHorizontallyScalable: true,
    availabilitySLA: 0.999,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 60,
    defaultConfig: {},
    education: {
      whatIsIt:
        "Stores conversation history, learnings, and context across agent sessions. Enables long-term memory — the agent remembers past interactions and decisions.",
      whenToUse: [
        "Multi-turn conversations requiring context",
        "Agents that learn from past interactions",
        "Personalized AI assistants",
      ],
      tradeoffs: {
        pros: [
          "Long-term context",
          "Personalization",
          "Learning from feedback",
        ],
        cons: [
          "Memory retrieval latency",
          "Privacy concerns with stored data",
          "Context window management",
        ],
      },
      realWorldExamples: ["Mem0 (formerly Embedchain)", "LangMem", "Zep"],
    },
    color: "#c77dff",
  },
  {
    type: "model-router",
    category: "ai",
    name: "Model Router",
    description:
      "Routes requests to optimal model based on complexity and cost",
    icon: "GitBranch",
    maxThroughput: 5000,
    baseLatency: 50,
    failureRateAtCapacity: 0.005,
    isHorizontallyScalable: true,
    availabilitySLA: 0.999,
    consistencyModel: "strong",
    capAlignment: "CP",
    costPerInstancePerMonth: 100,
    defaultConfig: {},
    education: {
      whatIsIt:
        "Routes each request to the best model based on complexity, cost, and latency. Simple questions go to cheap models, complex ones to powerful models.",
      whenToUse: [
        "Reducing AI costs by using right-sized models",
        "When traffic includes both simple and complex queries",
        "Multi-model deployment strategies",
      ],
      tradeoffs: {
        pros: [
          "40–70% cost reduction",
          "Optimized latency",
          "Quality preservation",
        ],
        cons: [
          "Router adds ~50ms latency",
          "Misclassification risk",
          "Requires quality benchmarking",
        ],
      },
      realWorldExamples: [
        "OpenRouter",
        "Martian",
        "RouteLLM",
        "Custom classifiers",
      ],
    },
    color: "#ffd60a",
  },
  {
    type: "training-cluster",
    category: "ai",
    name: "Training Cluster",
    description: "GPU cluster for model training and fine-tuning",
    icon: "Cpu",
    maxThroughput: 10,
    baseLatency: 10000,
    failureRateAtCapacity: 0.05,
    isHorizontallyScalable: true,
    availabilitySLA: 0.99,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 5000,
    defaultConfig: {},
    education: {
      whatIsIt:
        "A cluster of GPUs for training or fine-tuning ML models. Handles the compute-intensive process of learning from data.",
      whenToUse: [
        "Fine-tuning models on custom data",
        "Training custom models from scratch",
        "Continuous learning / retraining pipelines",
      ],
      tradeoffs: {
        pros: ["Custom model quality", "Full control", "Competitive advantage"],
        cons: [
          "Very expensive ($10K–$100K+/month)",
          "Requires ML engineering expertise",
          "Long iteration cycles",
        ],
      },
      realWorldExamples: [
        "AWS SageMaker Training",
        "Google Vertex AI",
        "Lambda Labs",
      ],
    },
    color: "#ffb800",
  },
  {
    type: "drift-detector",
    category: "ai",
    name: "Drift Detector",
    description: "Monitors model input/output for data and concept drift",
    icon: "TrendingDown",
    maxThroughput: 10000,
    baseLatency: 5,
    failureRateAtCapacity: 0.001,
    isHorizontallyScalable: true,
    availabilitySLA: 0.999,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 80,
    defaultConfig: {},
    education: {
      whatIsIt:
        "Monitors the distribution of model inputs and outputs over time. Detects when real-world data shifts away from training data, causing silent model degradation.",
      whenToUse: [
        "Any model serving real traffic",
        "When input distributions might change over time",
        "Compliance-regulated ML systems",
      ],
      tradeoffs: {
        pros: [
          "Early warning for quality issues",
          "Automated retraining triggers",
          "Compliance",
        ],
        cons: [
          "Statistical complexity",
          "False positive alerts",
          "Requires baseline data",
        ],
      },
      realWorldExamples: ["Evidently AI", "Arize", "WhyLabs", "NannyML"],
    },
    color: "#ff3860",
  },
  {
    type: "llm-observability",
    category: "ai",
    name: "LLM Observability",
    description: "Traces, logs, and evaluates LLM calls across your system",
    icon: "Eye",
    maxThroughput: 20000,
    baseLatency: 0,
    failureRateAtCapacity: 0.001,
    isHorizontallyScalable: true,
    availabilitySLA: 0.999,
    consistencyModel: "eventual",
    capAlignment: "AP",
    costPerInstancePerMonth: 100,
    defaultConfig: {},
    education: {
      whatIsIt:
        "Full observability for LLM-powered systems — traces every prompt/response, measures token costs, latency, and quality metrics per endpoint.",
      whenToUse: [
        "Any production LLM system",
        "Debugging prompt failures and quality issues",
        "Token cost attribution by endpoint",
      ],
      tradeoffs: {
        pros: ["Full visibility", "Cost tracking", "Quality evaluation"],
        cons: [
          "Storage costs grow with traffic",
          "PII in logged prompts",
          "Instrumentation overhead",
        ],
      },
      realWorldExamples: ["LangSmith", "Helicone", "Langfuse", "Arize Phoenix"],
    },
    color: "#00f5ff",
  },
];

// ─── Helper lookups ─────────────────────────────────────────────────────────

export const COMPONENT_MAP = new Map(
  COMPONENT_DEFINITIONS.map((def) => [def.type, def])
);

export function getComponentDefinition(
  type: string
): ComponentDefinition | undefined {
  return COMPONENT_MAP.get(type as ComponentType);
}

export function getComponentsByCategory(
  category: ComponentCategory
): ComponentDefinition[] {
  return COMPONENT_DEFINITIONS.filter((d) => d.category === category);
}
